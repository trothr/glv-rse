Lone Star Ruby Conference 2010, Aug 26–28

*Glenn Vanderburg*


Real Software Engineering
=========================
[video](http://www.youtube.com/watch?v=NP9AIUT9nos)
. [slides](http://cdn.oreillystatic.com/en/assets/1/event/40/Real%20Software%20Engineering%20Presentation.pdf)

Software engineering as it's taught in universities simply doesn't work. It
doesn't produce software systems of high quality, and it doesn't produce them
for low cost. Sometimes, even when practiced rigorously, it doesn't produce
systems at all.

That's odd, because in every other field, the term "engineering" is reserved
for methods that work.

What then, does real software engineering look like? How can we consistently
deliver high-quality systems to our customers and employers in a timely fashion
and for a reasonable cost? In this session, we'll discuss where software
engineering went wrong, and build the case that disciplined Agile methods, far
from being "anti-engineering" (as they are often described), actually represent
the best of engineering principles applied to the task of software development.


## Verbatim

Good morning! I'm Glenn Vanderburg, I work for InfoEther with [Rich Kilmer]
(https://www.wikiwand.com/en/Richard_Kilmer) and [Chad
Fowler](http://chadfowler.com/about/) and [Bruce
Williams](https://www.linkedin.com/in/wbruce) whom I suspect a lot of you know
here. And I'm here to talk about real software engineering. I've been at all
four out of Lone Star Ruby Confs and really enjoy them. So to start off with...

#### Software engineering doesn't work

Software engineering doesn't work... At least as it's currently taught in
universities and in training programs in companies if you happen to work for
one of the few companies that care about teaching such things. The techniques
that are taught and that are called "software engineering" simply don't work.
They don't reliably control costs. They don't reliably produce quality
software. Sometimes even when they're practiced rigorously by people who've
been trained to do so, they don't produce working software at all.

And that shouldn't really be suprising to any of us, because this seems to be
common knowledge among working programmers, all over this country at least...
But well... it's not surprising it is odd. Because in every other field that
aspires to the title of an engineering discipline the term "engineering" is
reserved for practices that work. In fact that's as good a capsule definition
of engineering independent of any particular discipline as you're likely to
find which is the set of practices and techniques that have been determined to
work reliably through experience. And yet in software we have this set of
practices that don't work and we call *that* engineering.

Now this is caused a lot of discussion, especially over the past year or so,
about whether software is really an engineering discipline at all and whether
software development really doesn't fit that metaphor. It's not engineering,
it's more like a craft or an art or something else or gardening or moviemaking
or various different analogies I've heard. And maybe engineering is just an
inappropriate metaphor for the task of building software. And I don't think
that's true. I do think software is an art, I do think it's a craft, I do think
it is in some respects a science. But that doesn't mean it can't also be
engineering. I say that the problem is that the people who have defined the set
of desciplines that we call "software engineering" have misunderstood two very
important things — software and engineering. And that has resulted in software
engineering being a caricature of an engineering descipline.

So I'm going to explain what I mean by this. And to do so I need first to start
off by explaining what I mean when I say that software is a caricature of
engineering and kind of how it got to be that way. And then I need to explain
what real engineering looks like. How many people in the room were trained as
engineers, not as software developers? Okay, intersting. I'm especially
intrested in feedback from people who have more of a classical engineering
background. Because I don't. I've had to kind of learn all this on my own. But
I think I've come to a pretty good understanding of where software engineering
got it wrong.

And then we're going to look at what real software development looks like. And
in the middle somewhere, I think, we can develop a picture of what real
software engineering is.

#### A Caricature of Engineering

So, the first time that the term "software engineering" really got bandied
about a lot was in 1968 at a conference in Garmisch, Germany, organised by
NATO, above all things. The first conference on software engineering sponsored
by the NATO science committee and at this time, you know, people were dealing
with what was called "the software crisis" and software projects were really
unreliable, and flaky, and error-prone, and failure-prone, and had huge cost
overruns. And people really didn't know much about how to manage them. So they
said: "You know, we need to kind of grow up as a discipline and as a field and
start becoming an engineering descipline." and so they had this conference.

I've known about and heard about this conference for many many years and never
really knew any details about it. And since I've got interested in this topic
I went and read the proceedings that are all online. And I was expecting to
find "ok, this is where the madness started". And in fact, no. I didn't find
that at all. The participants in this conference were by and large really smart
people who were working software developers. There are few academics, but the
academics had good things to say as well. And by and large the findings of this
conference were entirely reasonable and reflected a great deal of wisdom about
software and its state at the time. In fact mostly what you'll be impressed by
as you go there and read those proceedings if you do, is how willing they were
to admit that they didn't know anything. The conference is full of: "You know,
we're just kind of babes in the woods at this. It's a new field. It's different
from other fields before. There's all kind of stuff we don't know. We kind of
*think*, it might be like this." There is a lot of uncertainty.

[Alan Perlis](https://www.wikiwand.com/en/Alan_Perlis) gave a talk in which at
the end of the conference he sort of summarized the few things that the group
was able to all agree on about what software as engineering should look like.
The first of the three things were:

>   1. A software system can best be designed if the testing
>      is interlaced with the designing instead of being
>      used after the design.

That's pretty reasonable by our standards. Number two:

>   2. A simulation that matches the requirements contains
>      the control which organizes the design of the system.

Now the terminology has evolved since then, so that doesn't immediately seem
to make a lot of sense, but I think if you combine that with the third one, it
is clear what he means:

>   3. Through successive repetitions of this process of interlaced testing
>      and design the model ultimately becomes the software system itself.
>      [...] in effect the testing and the replacement of simulations with
>      modules that are deeper and more detailed goes on with the simulation
>      model controlling, as it were, the place and order in which these
>      things are done.

He was talking about [unit testing](https://www.wikiwand.com/en/Unit_testing),
and [mocking](http://www.wikiwand.com/en/Mock_object), and [iterative design
and development](https://www.wikiwand.com/en/Iterative_and_incremental_development).
Pretty reasonable.
